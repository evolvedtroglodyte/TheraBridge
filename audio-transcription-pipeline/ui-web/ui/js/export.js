/**
 * Export Module
 * Professional export functionality for transcription results
 * Supports: PDF, TXT, CSV, JSON formats
 */

class ExportManager {
    constructor() {
        this.speakerColors = {
            'SPEAKER_00': '#3B82F6',
            'SPEAKER_01': '#10B981',
            'SPEAKER_02': '#F59E0B',
            'SPEAKER_03': '#EF4444',
            'SPEAKER_04': '#8B5CF6',
            'SPEAKER_05': '#EC4899',
            'SPEAKER_06': '#14B8A6',
            'SPEAKER_07': '#F97316',
        };
        this.speakerLabels = {
            'SPEAKER_00': 'Therapist',
            'SPEAKER_01': 'Client'
        };
    }

    /**
     * Export to PDF with professional layout
     */
    async exportToPDF(resultsData, audioFilename = 'audio.mp3') {
        if (!resultsData || !resultsData.aligned_transcript) {
            alert('No data to export');
            return;
        }

        // Check if jsPDF is loaded
        if (typeof window.jspdf === 'undefined') {
            alert('PDF library not loaded. Please refresh the page and try again.');
            return;
        }

        try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            // PDF configuration
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            const margin = 20;
            const contentWidth = pageWidth - (margin * 2);
            let yPos = margin;

            // Color palette (RGB)
            const colors = {
                primary: [79, 70, 229],      // Indigo
                secondary: [107, 114, 128],  // Gray
                therapist: [59, 130, 246],   // Blue
                client: [16, 185, 129],      // Green
                border: [229, 231, 235]      // Light gray
            };

            // Helper function to add new page if needed
            const checkPageBreak = (requiredSpace) => {
                if (yPos + requiredSpace > pageHeight - margin) {
                    doc.addPage();
                    yPos = margin;
                    return true;
                }
                return false;
            };

            // Helper function to add footer
            const addFooter = (pageNum) => {
                doc.setFontSize(9);
                doc.setTextColor(...colors.secondary);
                doc.text(
                    `Page ${pageNum}`,
                    pageWidth / 2,
                    pageHeight - 10,
                    { align: 'center' }
                );
                doc.text(
                    `Generated by TherapyBridge Audio Diarization Pipeline`,
                    pageWidth / 2,
                    pageHeight - 6,
                    { align: 'center' }
                );
            };

            // ====================
            // PAGE 1: HEADER & METADATA
            // ====================

            // Title
            doc.setFontSize(24);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...colors.primary);
            doc.text('Audio Transcription Report', margin, yPos);
            yPos += 12;

            // Horizontal line
            doc.setDrawColor(...colors.border);
            doc.setLineWidth(0.5);
            doc.line(margin, yPos, pageWidth - margin, yPos);
            yPos += 10;

            // Metadata section
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(...colors.secondary);

            const metadata = [
                { label: 'Audio File:', value: audioFilename },
                { label: 'Date Generated:', value: new Date().toLocaleString() },
                { label: 'Number of Speakers:', value: this.countSpeakers(resultsData.aligned_transcript).toString() },
                { label: 'Total Segments:', value: resultsData.aligned_transcript.length.toString() },
            ];

            if (resultsData.performance) {
                if (resultsData.performance.audio_duration) {
                    metadata.push({
                        label: 'Audio Duration:',
                        value: this.formatDuration(resultsData.performance.audio_duration)
                    });
                }
                if (resultsData.performance.total_time) {
                    metadata.push({
                        label: 'Processing Time:',
                        value: this.formatDuration(resultsData.performance.total_time)
                    });
                }
            }

            metadata.forEach(item => {
                doc.setFont('helvetica', 'bold');
                doc.text(item.label, margin, yPos);
                doc.setFont('helvetica', 'normal');
                doc.text(item.value, margin + 50, yPos);
                yPos += 6;
            });

            yPos += 10;

            // ====================
            // SPEAKER STATISTICS
            // ====================

            checkPageBreak(40);

            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...colors.primary);
            doc.text('Speaker Statistics', margin, yPos);
            yPos += 8;

            const stats = this.calculateSpeakerStats(resultsData.aligned_transcript);

            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(0, 0, 0);

            // Table header
            const tableX = margin;
            const colWidths = [40, 20, 35, 30, 35];
            const headers = ['Speaker', 'Turns', 'Duration', 'Words', 'Avg Turn'];

            doc.setFillColor(245, 245, 245);
            doc.rect(tableX, yPos - 5, contentWidth, 8, 'F');

            let xOffset = tableX;
            headers.forEach((header, i) => {
                doc.text(header, xOffset + 2, yPos);
                xOffset += colWidths[i];
            });
            yPos += 8;

            // Table rows
            doc.setFont('helvetica', 'normal');
            Object.entries(stats).forEach(([speaker, data]) => {
                checkPageBreak(8);

                const label = this.speakerLabels[speaker] || speaker;
                xOffset = tableX;

                doc.text(label, xOffset + 2, yPos);
                xOffset += colWidths[0];

                doc.text(data.turns.toString(), xOffset + 2, yPos);
                xOffset += colWidths[1];

                doc.text(this.formatDuration(data.duration), xOffset + 2, yPos);
                xOffset += colWidths[2];

                doc.text(data.words.toString(), xOffset + 2, yPos);
                xOffset += colWidths[3];

                doc.text(this.formatDuration(data.avgTurn), xOffset + 2, yPos);

                yPos += 6;
            });

            yPos += 10;

            // ====================
            // TRANSCRIPT
            // ====================

            checkPageBreak(40);

            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...colors.primary);
            doc.text('Speaker-Labeled Transcript', margin, yPos);
            yPos += 10;

            doc.setFontSize(10);

            resultsData.aligned_transcript.forEach((segment, index) => {
                const speaker = this.speakerLabels[segment.speaker] || segment.speaker;
                const timestamp = `[${this.formatTimestamp(segment.start)} - ${this.formatTimestamp(segment.end)}]`;

                // Calculate text height
                const lines = doc.splitTextToSize(segment.text, contentWidth - 10);
                const segmentHeight = 12 + (lines.length * 5);

                checkPageBreak(segmentHeight);

                // Speaker header with color coding
                const speakerColor = this.getSpeakerColorRGB(segment.speaker);
                doc.setFillColor(...speakerColor);
                doc.roundedRect(margin, yPos - 4, contentWidth, 8, 2, 2, 'F');

                doc.setFont('helvetica', 'bold');
                doc.setTextColor(255, 255, 255);
                doc.text(`${speaker} ${timestamp}`, margin + 3, yPos);
                yPos += 8;

                // Transcript text
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(0, 0, 0);
                lines.forEach(line => {
                    doc.text(line, margin + 5, yPos);
                    yPos += 5;
                });

                yPos += 4;
            });

            // ====================
            // PROCESSING METRICS (if available)
            // ====================

            if (resultsData.performance && Object.keys(resultsData.performance).length > 0) {
                checkPageBreak(40);

                doc.setFontSize(12);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...colors.primary);
                doc.text('Processing Metrics', margin, yPos);
                yPos += 8;

                doc.setFontSize(9);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(...colors.secondary);

                const metricsText = [
                    `Transcription Time: ${this.formatDuration(resultsData.performance.transcription_time || 0)}`,
                    `Diarization Time: ${this.formatDuration(resultsData.performance.diarization_time || 0)}`,
                    `Alignment Time: ${this.formatDuration(resultsData.performance.alignment_time || 0)}`,
                    `Real-time Factor: ${(resultsData.performance.rtf || 0).toFixed(2)}x`
                ];

                metricsText.forEach(text => {
                    doc.text(text, margin, yPos);
                    yPos += 5;
                });
            }

            // Add footer to all pages
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                addFooter(i);
            }

            // Save PDF
            const filename = this.generateFilename(audioFilename, 'pdf');
            doc.save(filename);

            console.log('PDF exported successfully:', filename);

        } catch (error) {
            console.error('PDF export error:', error);
            alert('Failed to generate PDF: ' + error.message);
        }
    }

    /**
     * Export to enhanced TXT with metadata
     */
    exportToTXT(resultsData, audioFilename = 'audio.mp3') {
        if (!resultsData || !resultsData.aligned_transcript) {
            alert('No transcript to export');
            return;
        }

        let text = '';

        // Header
        text += '═══════════════════════════════════════════════════════════\n';
        text += '           AUDIO TRANSCRIPTION REPORT\n';
        text += '═══════════════════════════════════════════════════════════\n\n';

        // Metadata section
        text += 'METADATA\n';
        text += '───────────────────────────────────────────────────────────\n';
        text += `Audio File:         ${audioFilename}\n`;
        text += `Date Generated:     ${new Date().toLocaleString()}\n`;
        text += `Number of Speakers: ${this.countSpeakers(resultsData.aligned_transcript)}\n`;
        text += `Total Segments:     ${resultsData.aligned_transcript.length}\n`;

        if (resultsData.performance) {
            if (resultsData.performance.audio_duration) {
                text += `Audio Duration:     ${this.formatDuration(resultsData.performance.audio_duration)}\n`;
            }
            if (resultsData.performance.total_time) {
                text += `Processing Time:    ${this.formatDuration(resultsData.performance.total_time)}\n`;
            }
        }
        text += '\n';

        // Speaker statistics
        text += 'SPEAKER STATISTICS\n';
        text += '───────────────────────────────────────────────────────────\n';

        const stats = this.calculateSpeakerStats(resultsData.aligned_transcript);

        text += sprintf('%-15s %-10s %-15s %-10s %-15s\n',
            'Speaker', 'Turns', 'Duration', 'Words', 'Avg Turn'
        );
        text += '───────────────────────────────────────────────────────────\n';

        Object.entries(stats).forEach(([speaker, data]) => {
            const label = this.speakerLabels[speaker] || speaker;
            text += sprintf('%-15s %-10d %-15s %-10d %-15s\n',
                label,
                data.turns,
                this.formatDuration(data.duration),
                data.words,
                this.formatDuration(data.avgTurn)
            );
        });
        text += '\n';

        // Transcript
        text += 'SPEAKER-LABELED TRANSCRIPT\n';
        text += '───────────────────────────────────────────────────────────\n\n';

        resultsData.aligned_transcript.forEach((segment, index) => {
            const speaker = this.speakerLabels[segment.speaker] || segment.speaker;
            const timestamp = `[${this.formatTimestamp(segment.start)} - ${this.formatTimestamp(segment.end)}]`;

            text += `${speaker} ${timestamp}:\n`;
            text += `${segment.text}\n\n`;
        });

        // Processing metrics (if available)
        if (resultsData.performance && Object.keys(resultsData.performance).length > 0) {
            text += '───────────────────────────────────────────────────────────\n';
            text += 'PROCESSING METRICS\n';
            text += '───────────────────────────────────────────────────────────\n';

            if (resultsData.performance.transcription_time !== undefined) {
                text += `Transcription Time: ${this.formatDuration(resultsData.performance.transcription_time)}\n`;
            }
            if (resultsData.performance.diarization_time !== undefined) {
                text += `Diarization Time:   ${this.formatDuration(resultsData.performance.diarization_time)}\n`;
            }
            if (resultsData.performance.alignment_time !== undefined) {
                text += `Alignment Time:     ${this.formatDuration(resultsData.performance.alignment_time)}\n`;
            }
            if (resultsData.performance.rtf !== undefined) {
                text += `Real-time Factor:   ${resultsData.performance.rtf.toFixed(2)}x\n`;
            }
            text += '\n';
        }

        text += '═══════════════════════════════════════════════════════════\n';
        text += 'Generated by TherapyBridge Audio Diarization Pipeline\n';
        text += '═══════════════════════════════════════════════════════════\n';

        // Download as file
        this.downloadFile(text, this.generateFilename(audioFilename, 'txt'), 'text/plain');
        console.log('TXT exported successfully');
    }

    /**
     * Export to CSV for data analysis
     */
    exportToCSV(resultsData, audioFilename = 'audio.mp3') {
        if (!resultsData || !resultsData.aligned_transcript) {
            alert('No data to export');
            return;
        }

        // CSV header
        let csv = 'Speaker,Start Time,End Time,Duration,Text,Word Count\n';

        // CSV rows
        resultsData.aligned_transcript.forEach(segment => {
            const speaker = this.speakerLabels[segment.speaker] || segment.speaker;
            const startTime = this.formatTimestamp(segment.start);
            const endTime = this.formatTimestamp(segment.end);
            const duration = (segment.end - segment.start).toFixed(2);
            const text = this.escapeCsvField(segment.text);
            const wordCount = segment.text.split(/\s+/).length;

            csv += `"${speaker}","${startTime}","${endTime}","${duration}","${text}","${wordCount}"\n`;
        });

        // Download as file
        this.downloadFile(csv, this.generateFilename(audioFilename, 'csv'), 'text/csv');
        console.log('CSV exported successfully');
    }

    /**
     * Export to JSON (enhanced from original)
     */
    exportToJSON(resultsData, audioFilename = 'audio.mp3') {
        if (!resultsData) {
            alert('No results to export');
            return;
        }

        // Add metadata to JSON export
        const exportData = {
            metadata: {
                filename: audioFilename,
                exportDate: new Date().toISOString(),
                speakerCount: this.countSpeakers(resultsData.aligned_transcript || []),
                segmentCount: (resultsData.aligned_transcript || []).length
            },
            results: resultsData
        };

        const jsonString = JSON.stringify(exportData, null, 2);
        this.downloadFile(jsonString, this.generateFilename(audioFilename, 'json'), 'application/json');
        console.log('JSON exported successfully');
    }

    /**
     * Helper: Download file
     */
    downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    }

    /**
     * Helper: Generate filename
     */
    generateFilename(audioFilename, extension) {
        const baseName = audioFilename.replace(/\.[^/.]+$/, ''); // Remove original extension
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        return `${baseName}_transcript_${timestamp}.${extension}`;
    }

    /**
     * Helper: Calculate speaker statistics
     */
    calculateSpeakerStats(segments) {
        const stats = {};

        segments.forEach(segment => {
            const speaker = segment.speaker;
            if (!stats[speaker]) {
                stats[speaker] = {
                    turns: 0,
                    duration: 0,
                    words: 0
                };
            }

            stats[speaker].turns++;
            stats[speaker].duration += (segment.end - segment.start);
            stats[speaker].words += segment.text.split(/\s+/).length;
        });

        // Calculate average turn duration
        Object.keys(stats).forEach(speaker => {
            stats[speaker].avgTurn = stats[speaker].duration / stats[speaker].turns;
        });

        return stats;
    }

    /**
     * Helper: Count unique speakers
     */
    countSpeakers(segments) {
        const speakers = new Set(segments.map(s => s.speaker));
        return speakers.size;
    }

    /**
     * Helper: Format timestamp to MM:SS or HH:MM:SS
     */
    formatTimestamp(seconds) {
        const hours = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);

        if (hours > 0) {
            return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    /**
     * Helper: Format duration to human-readable string
     */
    formatDuration(seconds) {
        if (seconds < 60) {
            return `${seconds.toFixed(1)}s`;
        } else if (seconds < 3600) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}m ${secs}s`;
        } else {
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            return `${hours}h ${mins}m`;
        }
    }

    /**
     * Helper: Get speaker color as RGB array
     */
    getSpeakerColorRGB(speaker) {
        const hex = this.speakerColors[speaker] || '#64748B';
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return [r, g, b];
    }

    /**
     * Helper: Escape CSV field
     */
    escapeCsvField(text) {
        // Replace quotes with double quotes and escape newlines
        return text.replace(/"/g, '""').replace(/\n/g, ' ').replace(/\r/g, '');
    }
}

// Simple sprintf-like function for text formatting
function sprintf(format, ...args) {
    let index = 0;
    return format.replace(/%-?(\d+)([sd])/g, (match, width, type) => {
        const value = args[index++];
        const str = type === 's' ? String(value) : String(value);
        const len = parseInt(width);

        if (match.startsWith('%-')) {
            // Left-align
            return str.padEnd(len, ' ');
        } else {
            // Right-align
            return str.padStart(len, ' ');
        }
    });
}

// Export for global access
window.ExportManager = ExportManager;
